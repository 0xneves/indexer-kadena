import { Model, DataTypes } from "sequelize";
import { sequelize } from "../config/database";
import Block from "./block";
import { gql, makeExtendSchemaPlugin } from "postgraphile";

export interface TransactionAttributes {
  id: number;
  blockId: number;
  payloadHash: string;
  chainId: number;
  code: object;
  continuation: object;
  creationtime: string;
  data: object;
  gas: string;
  gaslimit: string;
  gasprice: string;
  hash: string;
  result: object;
  logs: object;
  metadata: object;
  nonce: string;
  num_events: number;
  pactid: string;
  proof: string;
  requestkey: string;
  rollback: boolean;
  sender: string;
  sigs: object;
  step: number;
  ttl: string;
  txid: string;
  canonical?: boolean;
}

/**
 * Represents a transaction in the blockchain.
 */
class Transaction extends Model<TransactionAttributes> implements TransactionAttributes {
  /** The unique identifier for the transaction record (e.g., 53411). */
  declare id: number;

  /** The ID of the associated block (e.g., 40515). */
  declare blockId: number;

  /** The result of the transaction (e.g., {"data": "Write succeeded", "status": "success"}). */
  declare result: object;

  /** The payload hash of the transaction (e.g., "mLsB6wcp2rvHTFJsk-gPQwR0n9ow1FQIXLktN15Cua4"). */
  declare payloadHash: string;

  /** The ID of the blockchain network (e.g., 0). */
  declare chainId: number;

  /** The code executed in the transaction (e.g., "(free.radio02.add-received-with-chain ...)"). */
  declare code: object;

  /** The continuation of the transaction (e.g., "{}"). */
  declare continuation: object;

  /** The creation time of the transaction (e.g., "1715747797"). */
  declare creationtime: string;

  /** The data associated with the transaction (e.g., {"keyset": {"keys": ["5c54af27ee3d53273bb7b7af9bfba9567e01bff4fbe70da3ee3a57b6d454dbd2"], "pred": "keys-all"}}). */
  declare data: object;

  /** The gas used in the transaction (e.g., "504"). */
  declare gas: string;

  /** The gas limit for the transaction (e.g., "1000"). */
  declare gaslimit: string;

  /** The gas price for the transaction (e.g., "0.000001"). */
  declare gasprice: string;

  /** The hash of the transaction (e.g., "S7v5RXHKgYAWAsnRfYWU_SUh6Jc4g4TU2HOEALj_JSU"). */
  declare hash: string;

  /** The logs generated by the transaction (e.g., "XGZIbkOVNtZkqzi1c2dUP-rrnwG0qALO-EVPXTZhV2I"). */
  declare logs: object;

  /** The metadata associated with the transaction (e.g., "{}"). */
  declare metadata: object;

  /** The nonce of the transaction (e.g., "2024-05-15T04:36:52.657Z"). */
  declare nonce: string;

  /** The number of events generated by the transaction (e.g., 1). */
  declare num_events: number;

  /** The pact ID of the transaction. */
  declare pactid: string;

  /** The proof of the transaction. */
  declare proof: string;

  /** The request key of the transaction (e.g., "S7v5RXHKgYAWAsnRfYWU_SUh6Jc4g4TU2HOEALj_JSU"). */
  declare requestkey: string;

  /** Indicates whether the transaction is a rollback (e.g., false). */
  declare rollback: boolean;

  /** The sender of the transaction (e.g., "k:5c54af27ee3d53273bb7b7af9bfba9567e01bff4fbe70da3ee3a57b6d454dbd2"). */
  declare sender: string;

  /** The signatures of the transaction (e.g., [{"sig": "4ad4b912d87d948a77a22082298463be66920a74fd02f742e0bf445cd3940f271098647db7a20d770c81b7ea0d8b733822b663f32b22985b14b9163321cb460d"}]). */
  declare sigs: object;

  /** The step of the transaction (e.g., 0). */
  declare step: number;

  /** The time-to-live of the transaction (e.g., "28800"). */
  declare ttl: string;

  /** The transaction ID (e.g., "309297606"). */
  declare txid: string;

  /** Indicates whether the transaction is canonical. */
  declare canonical?: boolean;
}

Transaction.init(
  {
    id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true, comment: "The unique identifier for the transaction record (e.g., 53411)." },
    blockId: { type: DataTypes.INTEGER, allowNull: true, comment: "The ID of the associated block (e.g., 40515)." },
    payloadHash: { type: DataTypes.STRING, comment: "The payload hash of the transaction (e.g., 'mLsB6wcp2rvHTFJsk-gPQwR0n9ow1FQIXLktN15Cua4')." },
    chainId: { type: DataTypes.INTEGER, comment: "The ID of the blockchain network (e.g., 0)." },
    code: { type: DataTypes.JSONB, comment: "The code executed in the transaction (e.g., '(free.radio02.add-received-with-chain ...)')." },
    continuation: { type: DataTypes.JSONB, comment: "The continuation of the transaction (e.g., '{}')." },
    creationtime: { type: DataTypes.STRING, comment: "The creation time of the transaction (e.g., '1715747797')." },
    data: { type: DataTypes.JSONB, comment: "The data associated with the transaction (e.g., {'keyset': {'keys': ['5c54af27ee3d53273bb7b7af9bfba9567e01bff4fbe70da3ee3a57b6d454dbd2'], 'pred': 'keys-all'}})." },
    gas: { type: DataTypes.STRING, comment: "The gas used in the transaction (e.g., '504')." },
    gaslimit: { type: DataTypes.STRING, comment: "The gas limit for the transaction (e.g., '1000')." },
    gasprice: { type: DataTypes.STRING, comment: "The gas price for the transaction (e.g., '0.000001')." },
    hash: { type: DataTypes.STRING, comment: "The hash of the transaction (e.g., 'S7v5RXHKgYAWAsnRfYWU_SUh6Jc4g4TU2HOEALj_JSU')." },
    result: { type: DataTypes.JSONB, comment: "The result of the transaction (e.g., {'data': 'Write succeeded', 'status': 'success'})." },
    logs: { type: DataTypes.JSONB, comment: "The logs generated by the transaction (e.g., 'XGZIbkOVNtZkqzi1c2dUP-rrnwG0qALO-EVPXTZhV2I')." },
    metadata: { type: DataTypes.JSONB, comment: "The metadata associated with the transaction (e.g., '{}')." },
    nonce: { type: DataTypes.STRING, comment: "The nonce of the transaction (e.g., '2024-05-15T04:36:52.657Z')." },
    num_events: { type: DataTypes.INTEGER, comment: "The number of events generated by the transaction (e.g., 1)." },
    pactid: { type: DataTypes.STRING, comment: "The pact ID of the transaction." },
    proof: { type: DataTypes.STRING, comment: "The proof of the transactio." },
    requestkey: { type: DataTypes.STRING, comment: "The request key of the transaction (e.g., 'S7v5RXHKgYAWAsnRfYWU_SUh6Jc4g4TU2HOEALj_JSU')." },
    rollback: { type: DataTypes.BOOLEAN, comment: "Indicates whether the transaction is a rollback (e.g., false)." },
    sender: { type: DataTypes.STRING, comment: "The sender of the transaction (e.g., 'k:5c54af27ee3d53273bb7b7af9bfba9567e01bff4fbe70da3ee3a57b6d454dbd2')." },
    sigs: { type: DataTypes.JSONB, comment: "The signatures of the transaction (e.g., [{'sig': '4ad4b912d87d948a77a22082298463be66920a74fd02f742e0bf445cd3940f271098647db7a20d770c81b7ea0d8b733822b663f32b22985b14b9163321cb460d'}])." },
    step: { type: DataTypes.INTEGER, comment: "The step of the transaction (e.g., 0)." },
    ttl: { type: DataTypes.STRING, comment: "The time-to-live of the transaction (e.g., '28800')." },
    txid: { type: DataTypes.STRING, comment: "The transaction ID (e.g., '309297606')." },
    canonical: { type: DataTypes.BOOLEAN, comment: "Indicates whether the transaction is canonical." },
  },
  {
    sequelize,
    modelName: "Transaction",
    indexes: [
      {
        name: "transactions_requestkey_idx",
        fields: ["requestkey"],
      },
      {
        name: "transactions_blockId_idx",
        fields: ["blockId"],
      },
    ],
  }
);

Transaction.belongsTo(Block, {
  foreignKey: "blockId",
});

export const transactionByRequestKeyQueryPlugin = makeExtendSchemaPlugin(
  (build) => {
    return {
      typeDefs: gql`
        extend type Query {
          transactionByRequestKey(requestkey: String!, eventLimit: Int, transferLimit: Int): TransactionData
        }

        type TransactionData {
          transaction: Transaction
          events: [Event]
          transfers: [TransferData]
        }

        type TransferData  {
          transfer: Transfer
          contract: Contract
        }
      `,
      resolvers: {
        Query: {
          transactionByRequestKey: async (
            _query,
            args,
            context,
            resolveInfo
          ) => {
            const { requestkey, eventLimit, transferLimit } = args;
            const { rootPgPool } = context;

            const { rows: transactions } = await rootPgPool.query(
              `SELECT * FROM public."Transactions" WHERE requestkey = $1`,
              [requestkey]
            );

            if (transactions.length === 0) {
              return null;
            }

            const transaction = transactions[0];

            const eventLimitClause = eventLimit ? `LIMIT $2` : '';
            const eventQueryParams = eventLimit ? [transaction.id, eventLimit] : [transaction.id];
            const { rows: events } = await rootPgPool.query(
              `SELECT * FROM public."Events" WHERE "transactionId" = $1 ${eventLimitClause}`,
              eventQueryParams
            );

            const transferLimitClause = transferLimit ? `LIMIT $2` : '';
            const transferQueryParams = transferLimit ? [transaction.id, transferLimit] : [transaction.id];
            const { rows: transfers } = await rootPgPool.query(
              `SELECT * FROM public."Transfers" WHERE "transactionId" = $1 ${transferLimitClause}`,
              transferQueryParams,
            );

            const transferDataPromises = transfers.map(async (transfer: any) => {
              let contract = null;
              transfer.toAcct = transfer.to_acct;
              transfer.fromAcct = transfer.from_acct;
              if (transfer.contractId) {
                const { rows: contracts } = await rootPgPool.query(
                  `SELECT * FROM public."Contracts" WHERE id = $1`,
                  [transfer.contractId]
                );
                contract = contracts.length > 0 ? contracts[0] : null;
              }

              return {
                transfer,
                contract,
              };
            });

            const transferData = await Promise.all(transferDataPromises);

            transaction.numEvents = events.length;

            return {
              transaction,
              events,
              transfers: transferData,
            };
          }
        },
      },
    };
  }
);

export const transactionsByBlockIdQueryPlugin = makeExtendSchemaPlugin(
  (build) => {
    return {
      typeDefs: gql`
        extend type Query {
          transactionsByBlockId(
            blockId: Int!
            first: Int
            after: String
          ): TransactionConnection
        }

        type TransactionConnection {
          edges: [TransactionEdge]
          pageInfo: PageInfo
        }

        type TransactionEdge {
          node: Transaction
          cursor: String
        }
      `,
      resolvers: {
        Query: {
          transactionsByBlockId: async (_query, args, context, resolveInfo) => {
            const { blockId, first, after } = args;
            const { rootPgPool } = context;

            let cursorCondition = "";
            const limit = first || 10;
            const values = [blockId, limit + 1];

            if (after) {
              cursorCondition = "AND id > $3";
              values.push(Buffer.from(after, "base64").toString("ascii"));
            }

            const query = `
            SELECT * FROM public."Transactions"
            WHERE "blockId" = $1
            ${cursorCondition}
            ORDER BY id
            LIMIT $2
          `;

            const { rows } = await rootPgPool.query(query, values);

            const hasNextPage = rows.length > limit;
            if (hasNextPage) {
              rows.pop();
            }

            const edges = rows.map((row: any) => ({
              node: row,
              cursor: Buffer.from(row.id.toString(), "ascii").toString(
                "base64"
              ),
            }));

            const endCursor =
              edges.length > 0 ? edges[edges.length - 1].cursor : null;

            return {
              edges,
              pageInfo: {
                endCursor,
                hasNextPage,
              },
            };
          },
        },
      },
    };
  }
);

export default Transaction;
